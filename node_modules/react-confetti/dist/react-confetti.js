(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react')) :
  typeof define === 'function' && define.amd ? define(['react'], factory) :
  (global.ReactConfetti = factory(global.React));
}(this, (function (React) { 'use strict';

  React = React && React.hasOwnProperty('default') ? React['default'] : React;

  function degreesToRads(degrees) {
    return degrees / (180 * Math.PI);
  }

  function randomRange(min, max) {
    return min + Math.random() * (max - min);
  }

  function randomInt(min, max) {
    return Math.floor(min + Math.random() * (max - min + 1));
  }

  /**
   * Most of this was coppied directly from the pen at http://codepen.io/Gthibaud/pen/BoaBZK
   * and halfheartedly converted to es6.
   */
  function confetti(canvas) {
    var numberOfPieces = 200;
    var confettiSource = {
      x: 0,
      y: 0,
      w: canvas.width,
      h: 0
    };
    var friction = 0.99;
    var wind = 0;
    var gravity = 0.1;
    var colors = ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4CAF50', '#8BC34A', '#CDDC39', '#FFEB3B', '#FFC107', '#FF9800', '#FF5722', '#795548'];
    var opacity = 1.0;
    var recycle = true;
    var run = true;

    function self() {
      var context = canvas.getContext('2d');

      function Particle(x, y) {
        this.radius = randomRange(0.1, 1);
        this.x = x;
        this.y = y;
        this.vx = randomRange(-4, 4);
        this.vy = randomRange(-10, -0);
        this.type = randomInt(0, 1);

        this.w = randomRange(5, 20);
        this.h = randomRange(5, 20);

        this.r = randomRange(5, 10);

        this.angle = degreesToRads(randomRange(0, 360));
        this.anglespin = randomRange(-0.2, 0.2);
        this.color = colors[Math.floor(Math.random() * colors.length)];

        this.rotateY = randomRange(0, 1);
      }

      Particle.prototype.update = function updateParticle() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += gravity;
        this.vx += wind;
        this.vx *= friction;
        this.vy *= friction;
        this.radius -= 0.02;
        if (this.rotateY < 1) {
          this.rotateY += 0.1;
        } else {
          this.rotateY = -1;
        }
        this.angle += this.anglespin;
        context.save();
        context.translate(this.x, this.y);
        context.rotate(this.angle);
        context.scale(1, this.rotateY);
        context.rotate(this.angle);
        context.beginPath();
        context.fillStyle = this.color;
        context.strokeStyle = this.color;
        context.globalAlpha = opacity;
        context.lineCap = 'round';
        context.lineWidth = 2;
        if (this.type === 0) {
          context.beginPath();
          context.arc(0, 0, this.r, 0, 2 * Math.PI);
          context.fill();
        } else if (this.type === 2) {
          context.beginPath();
          for (var i = 0; i < 22; i++) {
            var angle = 0.5 * i;
            var x = (0.2 + 1.5 * angle) * Math.cos(angle);
            var y = (0.2 + 1.5 * angle) * Math.sin(angle);
            context.lineTo(x, y);
          }
          context.stroke();
        } else if (this.type === 1) {
          context.fillRect(-this.w / 2, -this.h / 2, this.w, this.h);
        }
        context.closePath();
        context.restore();
      };

      function ParticleGenerator(source, number, text) {
        // particle will spawn in this aera
        this.x = source.x;
        this.y = source.y;
        this.w = source.w;
        this.h = source.h;
        this.number = number;
        this.particles = [];
        this.particlesGenerated = 0;
        this.text = text;
        this.recycle = recycle;
      }
      ParticleGenerator.prototype.removeParticleAt = function removeParticleAt(i) {
        this.particles.splice(i, 1);
      };
      ParticleGenerator.prototype.getParticle = function addParticle() {
        var newParticleX = randomRange(this.x, this.w + this.x);
        var newParticleY = randomRange(this.y, this.h + this.y);
        return new Particle(newParticleX, newParticleY, this.text);
      };
      ParticleGenerator.prototype.animate = function animateParticle() {
        var _this = this;

        if (!run) {
          return false;
        }
        var nP = this.particles.length;
        var limit = this.recycle ? nP : this.particlesGenerated;
        if (limit < this.number) {
          this.particles.push(this.getParticle());
          this.particlesGenerated += 1;
        }

        this.particles.forEach(function (p, i) {
          p.update();
          if (p.y > canvas.height || p.y < -100 || p.x > canvas.width + 100 || p.x < -100) {
            if (recycle && limit <= _this.number) {
              // a brand new particle replacing the dead one
              _this.particles[i] = _this.getParticle();
            } else {
              _this.removeParticleAt(i);
            }
          }
        });
        return nP > 0 || limit < this.number;
      };

      self.particleGenerator = new ParticleGenerator(confettiSource, numberOfPieces);

      self.update = function () {
        if (run) {
          self.particleGenerator.number = numberOfPieces;
          // context.globalAlpha=.5;
          context.fillStyle = 'white';
          context.clearRect(0, 0, canvas.width, canvas.height);
        }
        if (self.particleGenerator.animate()) {
          requestAnimationFrame(self.update);
        } else {
          run = false;
        }
      };

      self.update();

      return self;
    }

    self.numberOfPieces = function () {
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      if (!args.length) {
        return numberOfPieces;
      }
      numberOfPieces = args[0];

      if (self.particleGenerator) {
        self.particleGenerator.number = numberOfPieces;
      }
      return self;
    };

    self.friction = function () {
      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      if (!args.length) {
        return friction;
      }
      friction = args[0];

      return self;
    };

    self.wind = function () {
      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      if (!args.length) {
        return wind;
      }
      wind = args[0];

      return self;
    };

    self.gravity = function () {
      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      if (!args.length) {
        return gravity;
      }
      gravity = args[0];

      return self;
    };

    self.colors = function () {
      for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      if (!args.length) {
        return colors;
      }
      colors = args[0];

      return self;
    };

    self.opacity = function () {
      for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        args[_key6] = arguments[_key6];
      }

      if (!args.length) {
        return opacity;
      }
      opacity = args[0];

      return self;
    };

    self.recycle = function () {
      for (var _len7 = arguments.length, args = Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        args[_key7] = arguments[_key7];
      }

      if (!args.length) {
        return recycle;
      }
      recycle = args[0];

      if (self.particleGenerator) {
        self.particleGenerator.recycle = recycle;
      }
      return self;
    };

    self.confettiSource = function () {
      if (!arguments.length) {
        return confettiSource;
      }
      confettiSource = Object.assign(confettiSource, arguments.length <= 0 ? undefined : arguments[0]);
      return self;
    };

    self.run = function () {
      for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
        args[_key8] = arguments[_key8];
      }

      if (!args.length) {
        return run;
      }
      var wasRunning = run;
      var isRunning = args[0];

      run = isRunning;
      if (!wasRunning && run) {
        self.update();
      }
      return self;
    };

    return self;
  }

  var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

  var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

  function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var ReactConfetti = function (_React$PureComponent) {
    _inherits(ReactConfetti, _React$PureComponent);

    function ReactConfetti() {
      _classCallCheck(this, ReactConfetti);

      return _possibleConstructorReturn(this, (ReactConfetti.__proto__ || Object.getPrototypeOf(ReactConfetti)).apply(this, arguments));
    }

    _createClass(ReactConfetti, [{
      key: 'componentDidMount',
      value: function componentDidMount() {
        this.confetti = confetti(this.canvas).numberOfPieces(this.props.numberOfPieces).confettiSource(this.props.confettiSource).friction(this.props.friction).wind(this.props.wind).gravity(this.props.gravity).colors(this.props.colors).opacity(this.props.opacity).recycle(this.props.recycle).run(this.props.run)();
      }
    }, {
      key: 'componentWillReceiveProps',
      value: function componentWillReceiveProps(nextProps) {
        this.confetti.numberOfPieces(nextProps.numberOfPieces).confettiSource(nextProps.confettiSource).friction(nextProps.friction).wind(nextProps.wind).gravity(nextProps.gravity).colors(nextProps.colors).opacity(nextProps.opacity).recycle(nextProps.recycle).run(nextProps.run);
      }
    }, {
      key: 'render',
      value: function render() {
        var _this2 = this;

        var _props = this.props,
            width = _props.width,
            height = _props.height,
            style = _props.style,
            numberOfPieces = _props.numberOfPieces,
            friction = _props.friction,
            wind = _props.wind,
            gravity = _props.gravity,
            colors = _props.colors,
            opacity = _props.opacity,
            recycle = _props.recycle,
            confettiSource = _props.confettiSource,
            run = _props.run,
            passedProps = _objectWithoutProperties(_props, ['width', 'height', 'style', 'numberOfPieces', 'friction', 'wind', 'gravity', 'colors', 'opacity', 'recycle', 'confettiSource', 'run']);

        var canvasStyles = Object.assign({}, {
          zIndex: 2,
          position: 'absolute',
          top: 0,
          left: 0,
          pointerEvents: 'none',
          WebkitPointerEvents: 'none',
          MozPointerEvents: 'none'
        }, style);

        return React.createElement('canvas', _extends({
          width: width,
          height: height,
          ref: function ref(c) {
            _this2.canvas = c;
          },
          style: canvasStyles
        }, passedProps));
      }
    }]);

    return ReactConfetti;
  }(React.PureComponent);

  ReactConfetti.defaultProps = {
    numberOfPieces: 200,
    confettiSource: {},
    friction: 0.99,
    wind: 0,
    gravity: 0.1,
    colors: ['#f44336', '#e91e63', '#9c27b0', '#673ab7', '#3f51b5', '#2196f3', '#03a9f4', '#00bcd4', '#009688', '#4CAF50', '#8BC34A', '#CDDC39', '#FFEB3B', '#FFC107', '#FF9800', '#FF5722', '#795548'],
    opacity: 1.0,
    recycle: true,
    run: true
  };

  return ReactConfetti;

})));
//# sourceMappingURL=react-confetti.js.map
